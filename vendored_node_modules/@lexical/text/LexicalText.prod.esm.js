/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import{$isElementNode as t,$isTextNode as e,$getRoot as n,$isDecoratorNode as r,$isParagraphNode as i,TextNode as o,$createTextNode as l}from"lexical";function s(n,r){let i=n.getFirstChild(),o=0;t:for(;null!==i;){if(t(i)){const t=i.getFirstChild();if(null!==t){i=t;continue}}else if(e(i)){const t=i.getTextContentSize();if(o+t>r)return{node:i,offset:r-o};o+=t}const n=i.getNextSibling();if(null!==n){i=n;continue}let l=i.getParent();for(;null!==l;){const t=l.getNextSibling();if(null!==t){i=t;continue t}l=l.getParent()}break}return null}function u(t,e=!0){if(t)return!1;let n=c();return e&&(n=n.trim()),""===n}function f(t,e){return()=>u(t,e)}function c(){return n().getTextContent()}function g(o){if(!u(o,!1))return!1;const l=n().getChildren(),s=l.length;if(s>1)return!1;for(let n=0;n<s;n++){const o=l[n];if(r(o))return!1;if(t(o)){if(!i(o))return!1;if(0!==o.__indent)return!1;const t=o.getChildren(),r=t.length;for(let i=0;i<r;i++){const r=t[n];if(!e(r))return!1}}}return!0}function x(t){return()=>g(t)}function a(t,n,r,i){const s=t=>t instanceof r,u=t=>{const e=l(t.getTextContent());e.setFormat(t.getFormat()),t.replace(e)};return[t.registerNodeTransform(o,(t=>{if(!t.isSimpleText())return;const r=t.getPreviousSibling();let o,l=t.getTextContent(),f=t;if(e(r)){const e=r.getTextContent(),i=n(e+l);if(s(r)){if(null===i||0!==(t=>t.getLatest().__mode)(r))return void u(r);{const n=i.end-e.length;if(n>0){const i=e+l.slice(0,n);if(r.select(),r.setTextContent(i),n===l.length)t.remove();else{const e=l.slice(n);t.setTextContent(e)}return}}}else if(null===i||i.start<e.length)return}for(;;){o=n(l);let t,c=null===o?"":l.slice(o.end);if(l=c,""===c){const t=f.getNextSibling();if(e(t)){c=f.getTextContent()+t.getTextContent();const e=n(c);if(null===e)return void(s(t)?u(t):t.markDirty());if(0!==e.start)return}}else{const t=n(c);if(null!==t&&0===t.start)return}if(null===o)return;if(0===o.start&&e(r)&&r.isTextEntity())continue;0===o.start?[t,f]=f.splitText(o.end):[,t,f]=f.splitText(o.start,o.end);const g=i(t);if(g.setFormat(t.getFormat()),t.replace(g),null==f)return}})),t.registerNodeTransform(r,(t=>{const r=t.getTextContent(),i=n(r);if(null===i||0!==i.start)return void u(t);if(r.length>i.end)return void t.splitText(i.end);const o=t.getPreviousSibling();e(o)&&o.isTextEntity()&&(u(o),u(t));const l=t.getNextSibling();e(l)&&l.isTextEntity()&&(u(l),s(t)&&u(t))}))]}export{g as $canShowPlaceholder,x as $canShowPlaceholderCurry,s as $findTextIntersectionFromCharacters,u as $isRootTextContentEmpty,f as $isRootTextContentEmptyCurry,c as $rootTextContent,a as registerLexicalTextEntity};
